package com.xl.jzoffer;

public class jz_56_2_Mark {
    // 这个思路 很好
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int cnt = 0;
            for (int n : nums) {
                // n & 1 << i 的值大于0即为真
                if ((n & (1 << i)) > 0) cnt++;
            }
            // 构造只出现一次的那个数字，采用异或的方法生成二进制中的每一位
            if (cnt % 3 != 0) ans ^= (1 << i);
        }
        return ans;
    }

    public static void main(String[] args) {
        //二进制数在内存中是以补码的形式存放的。
        //补码首位是符号位,0表示此数为正数,1表示此数为负数。
        //正数的补码、反码,都是其本身。
        //负数的反码是:符号位为1,其余各位求反,但末位不加1 。
        //负数的补码是:符号位不变,其余各位求反,末位加1 。
        int d = 9;
        //因为正数的补码就是自己，所以正数直接开始操作，
        // 取反之后，其实还是补码，
        // 如果取反之后是负数，还要转换成负数的原码才行
        /*00000000 00000000 00000000 00001001
         * ->取反
         * 11111111 11111111 11111111 11110110
         * ->减一
         * 11111111 11111111 11111111 11110101
         * ->符号位不变 数值位取反
         * 10000000 00000000 00000000 00001010*/
        System.out.println(~d);//结果为-10

        int d2 = -9;
        /*10000000 00000000 00000000 00001001
         * ->转补码
         * 11111111 11111111 11111111 11110111
         * ->取反
         * 00000000 00000000 00000000 00001000
         * 因为正数的补码、反码全是原码，
         * 所以负数先转换成补码，然后取反，
         * 这肯定是一个正数，所以这个补码跟原码是一样的
         * */
        System.out.println(~d2);//结果为8


    }
}
